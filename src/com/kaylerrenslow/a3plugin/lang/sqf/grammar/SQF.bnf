{
  parserClass="com.kaylerrenslow.a3plugin.lang.sqf.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.a3plugin.lang.sqf.psi"
  psiImplPackage="com.kaylerrenslow.a3plugin.lang.sqf.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFTokenType"

  psiImplUtilClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFPsiImplUtilForGrammar"

  name("return_statement")="Return Statement"
  name("try_catch")="try-catch block"
  name("macro_call")="Macro Call"
  name("assignment")="Assignment"
  name("if_statement")="If Statement"
  name("expression")="Expression"
  name("terminal_")="Terminal"
  name("exp_operand_")="Terminal"

}
// @formatter:off
sqfFile ::= file_scope //need both file_scope and scope or sqfFile will be discarded

file_scope ::= item_* return_statement? (whitespace_comment_ | BAD_CHARACTER)* {extends("file_scope")=local_scope}
local_scope ::= item_* return_statement? (whitespace_comment_ | BAD_CHARACTER)* {implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFScope" methods=[getPrivateDeclaredVars]}

private item_ ::= whitespace_comment_ | statement | BAD_CHARACTER
private whitespace_comment_ ::= WHITE_SPACE | comment
comment ::= INLINE_COMMENT | BLOCK_COMMENT | COMMENT_COMMAND
variable ::= GLOBAL_VAR | LOCAL_VAR | LANG_VAR {mixin="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFVariableNamedElementMixin" implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFVariableNamedElement" methods=[followsSQFFunctionNameRules getDeclarationScope]}


statement ::= ( assignment
				| private_decl
				| scope_manager
				| control_struct_
				| try_catch
				| expression
			  ) SEMICOLON

return_statement ::= expression SEMICOLON?

assignment ::= variable EQ (assignment | expression | switch_statement | if_statement | code_block) {methods=[getAssigningVariable]}

expression::= exp_operand_ exp_operator_ expression | exp_operand_
private exp_operand_ ::= (PLUS | MINUS | NOT | EXCL)? (macro_call | terminal_ COMMAND exp_operand_? | COMMAND exp_operand_ | COMMAND | terminal_)
			 | code_block
			 | ASSERT LPAREN expression RPAREN

private exp_operator_ ::= PLUS
			  | MINUS

			  | ASTERISK
			  | FSLASH
			  | PERC
			  | MOD
			  | CARET

			  | AND
			  | AMPAMP
			  | OR
			  | BARBAR

			  | EXCL
			  | NOT
			  | EQEQ
			  | NE
			  | LT
			  | GT
			  | LE
			  | GE

			  | GTGT


private terminal_ ::= string
					| variable
					| INTEGER_LITERAL
					| array_val
					| DEC_LITERAL
					| TRUE
					| FALSE
					| CONFIG
					| TYPE_NULL
					| NIL
					| NAMESPACE
					| LPAREN expression RPAREN

string ::= STRING_LITERAL

macro_call ::= variable LPAREN expression (COMMA expression)* RPAREN

array_val ::= LBRACKET (expression (COMMA expression)*)? RBRACKET


code_block ::= LBRACE local_scope RBRACE

/*control structures and other things*/
    private_decl ::= PRIVATE ( private_decl_var | LBRACKET (private_decl_var (COMMA private_decl_var)*) RBRACKET) //do not allow private[]
	private_decl_var ::= string {mixin="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFPrivateDeclVarMixin" implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFVariableElement"}


    scope_manager ::= GOTO COLON string
				    | BREAK_TO string
				    | expression? BREAK_OUT string
				    | CONTINUE
				    | BREAK
				    | SCOPE_NAME string

    private control_struct_ ::= if_statement | switch_statement | loop_ | wait_until_statement | with_statement | quest_statement
    if_statement ::= IF LPAREN expression RPAREN (
				     THEN code_block (ELSE code_block)?
				   | EXIT_WITH code_block
				   | THROW value
			      )

    switch_statement ::= SWITCH (LPAREN expression RPAREN | expression) DO LBRACE (switch_case)* RBRACE
    switch_case ::= (CASE expression COLON code_block SEMICOLON)
				  | (DEFAULT code_block SEMICOLON)

    private loop_ ::= loop_while | for_loops_
    loop_while    ::= WHILE LBRACE expression RBRACE DO code_block
    private for_loops_ ::= loop_for | loop_for_from | loop_for_each
    loop_for  ::= FOR LBRACKET code_block COMMA LBRACE expression RBRACE COMMA code_block RBRACKET DO code_block
    loop_for_from ::= FOR string FROM expression TO expression (STEP expression)? DO code_block
    loop_for_each ::= code_block FOR_EACH expression

    quest_statement ::= QUEST expression COLON exp

    try_catch ::= TRY code_block CATCH code_block

    wait_until_statement ::= WAIT_UNTIL code_block

    with_statement ::= WITH NAMESPACE DO code_block
