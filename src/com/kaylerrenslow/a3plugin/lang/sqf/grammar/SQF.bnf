{
  parserClass="com.kaylerrenslow.a3plugin.lang.sqf.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.a3plugin.lang.sqf.psi"
  psiImplPackage="com.kaylerrenslow.a3plugin.lang.sqf.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFTokenType"

  psiImplUtilClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.helpers.SQFPsiImplUtil"

  name("return_statement")="return statement"
  name("try_catch")="try-catch block"
  name("macro_call")="macro call"

}
// @formatter:off
sqfFile ::= file_scope //need both file_scope and scope or sqfFile will be discarded

file_scope ::= item_* return_statement? (whitespace_comment_ | BAD_CHARACTER)* {extends("file_scope")=scope}
scope ::= item_* return_statement? (whitespace_comment_ | BAD_CHARACTER)*

private item_ ::= whitespace_comment_ | statement | BAD_CHARACTER
private whitespace_comment_ ::= WHITE_SPACE | comment_
private comment_ ::= COMMENT | BLOCK_COMMENT | COMMENT_KEYWORD STRING_LITERAL
variable ::= GLOBAL_VAR | LOCAL_VAR | LANG_VAR {mixin="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFVariableNamedElementMixin" implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFVariableNamedElement" methods=[]}


statement ::= ( assignment
				| private_decl
				| scope_manager
				| control_struct_
				| try_catch
				| expression
			  ) SEMICOLON

return_statement ::= expression SEMICOLON?

assignment ::= variable EQ (assignment | expression | switch_statement | if_statement | code_block)

expression::= exp_operand_ exp_operator_ expression | exp_operand_
private exp_operand_ ::= (PLUS | MINUS | NOT | EXCL)? (macro_call | terminal_ COMMAND exp_operand_? | COMMAND exp_operand_ | COMMAND | terminal_)
			 | code_block
			 | ASSERT LPAREN expression RPAREN

private exp_operator_ ::= PLUS
			  | MINUS

			  | ASTERISK
			  | FSLASH
			  | PERC
			  | MOD
			  | CARET

			  | AND
			  | AMPAMP
			  | OR
			  | BARBAR

			  | EXCL
			  | NOT
			  | EQEQ
			  | NE
			  | LT
			  | GT
			  | LE
			  | GE

			  | GTGT


private terminal_ ::= STRING_LITERAL
					| variable
					| INTEGER_LITERAL
					| array_val
					| DEC_LITERAL
					| TRUE
					| FALSE
					| CONFIG
					| TYPE_NULL
					| NIL
					| NAMESPACE
					| LPAREN expression RPAREN


macro_call ::= variable LPAREN expression (COMMA expression)* RPAREN

array_val ::= LBRACKET (expression (COMMA expression)*)? RBRACKET


code_block ::= LBRACE scope RBRACE

/*control structures and other things*/
    private_decl ::= PRIVATE ( variable_as_string | LBRACKET (variable_as_string (COMMA variable_as_string)*) RBRACKET)
	variable_as_string ::= STRING_LITERAL {mixin="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFVariableAsStringMixin" implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFVariableElement"}


    scope_manager ::= GOTO COLON STRING_LITERAL
				    | BREAK_TO STRING_LITERAL
				    | expression? BREAK_OUT STRING_LITERAL
				    | CONTINUE
				    | BREAK
				    | SCOPE_NAME STRING_LITERAL

    private control_struct_ ::= if_statement | switch_statement | loop_ | wait_until_statement | with_statement | quest_statement
    if_statement ::= IF LPAREN expression RPAREN (
				     THEN code_block (ELSE code_block)?
				   | EXIT_WITH code_block
				   | THROW value
			      )

    switch_statement ::= SWITCH (LPAREN expression RPAREN | expression) DO LBRACE (switch_case)* RBRACE
    switch_case ::= (CASE expression COLON code_block SEMICOLON)
				  | (DEFAULT code_block SEMICOLON)

    private loop_ ::= loop_while | for_loops_
    loop_while    ::= WHILE LBRACE expression RBRACE DO code_block
    private for_loops_ ::= loop_for | loop_for_from | loop_for_each
    loop_for  ::= FOR LBRACKET code_block COMMA LBRACE expression RBRACE COMMA code_block RBRACKET DO code_block
    loop_for_from ::= FOR variable_as_string FROM expression TO expression (STEP expression)? DO code_block
    loop_for_each ::= code_block FOR_EACH expression

    quest_statement ::= QUEST expression COLON exp

    try_catch ::= TRY code_block CATCH code_block

    wait_until_statement ::= WAIT_UNTIL code_block

    with_statement ::= WITH NAMESPACE DO code_block
