{
  parserClass="com.kaylerrenslow.a3plugin.lang.sqf.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.a3plugin.lang.sqf.psi"
  psiImplPackage="com.kaylerrenslow.a3plugin.lang.sqf.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFTokenType"

  psiImplUtilClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFPsiImplUtilForGrammar"

  name("return_statement")="Return Statement"
  name("macro_call")="Macro Call"
  name("assignment")="Assignment"
  name("expression")="Expression"
  extends(".*expression")=expression
  extends(".*_statement")=statement
}
// @formatter:off
sqfFile ::= file_scope //need both file_scope and scope or sqfFile will be discarded

file_scope ::= item_* return_statement? (comment | BAD_CHARACTER)* {extends("file_scope")=local_scope}
local_scope ::= item_* return_statement? (comment | BAD_CHARACTER)* {implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFScope" methods=[getPrivateDeclaredVars getStatementsForScope checkIfSpawn]}

private item_ ::= comment | statement | BAD_CHARACTER

comment ::= INLINE_COMMENT | BLOCK_COMMENT | COMMENT_COMMAND
variable ::= GLOBAL_VAR | LOCAL_VAR | LANG_VAR {mixin="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFVariableNamedElementMixin" implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFVariableNamedElement" methods=[followsSQFFunctionNameRules getDeclarationScope isAssigningVariable getMyAssignment getPrivatization varNameMatches]}

statement ::= ( assignment | expression | quest_statement) SEMICOLON

return_statement ::= expression SEMICOLON?
quest_statement ::= QUEST expression COLON expression

assignment ::= (COMMAND? variable) EQ (expression | code_block) {methods=[getAssigningVariable isDeclaredPrivate]}

expression ::= conditional_group_
            | comparison_group_
            | mul_group_
            | unary_group_
            | exponent_expression
            | add_group_
            | config_fetch_expression
            | command_expression
            | primary_group_

private add_group_ ::= add_expression | sub_expression
private mul_group_ ::= mul_expression | div_expression | mod_expression
private unary_group_ ::= unary_plus_expression | unary_min_expression
private conditional_group_::= bool_and_expression | bool_or_expression | bool_not_expression
private comparison_group_ ::= comp_expression

private primary_group_ ::= string
                         | macro_call
                         | variable
                         | INTEGER_LITERAL
                         | array_val
                         | DEC_LITERAL

add_expression ::= expression PLUS expression
sub_expression ::= expression MINUS expression
mul_expression ::= expression ASTERISK expression
div_expression ::= expression FSLASH expression
mod_expression ::= expression (PERC | MOD) expression

bool_and_expression ::= expression (AND | AMPAMP) expression
bool_or_expression ::= expression (OR | BARBAR) expression
bool_not_expression::= (NOT | EXCL) expression

comp_expression ::= expression (EQEQ | NE | LT | LE | GT | GE) expression

config_fetch_expression ::= expression (FSLASH | GTGT) expression

unary_plus_expression ::= PLUS expression
unary_min_expression ::= MINUS expression
exponent_expression ::= expression (CARET expression)+
command_expression ::= command_operand_ COMMAND command_operand_? | COMMAND command_operand_ | COMMAND
    private command_operand_ ::= unary_group_| primary_group_ | paren_expression | code_block
paren_expression ::= LPAREN expression RPAREN


string ::= STRING_LITERAL {mixin="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFStringMixin" methods=[getNonQuoteText]}

macro_call ::= variable LPAREN expression (COMMA expression)* RPAREN

array_val ::= LBRACKET (expression | code_block (COMMA expression | code_block)*)? RBRACKET

code_block ::= LBRACE local_scope? RBRACE
