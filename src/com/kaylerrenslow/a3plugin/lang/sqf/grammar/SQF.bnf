{
  parserClass="com.kaylerrenslow.a3plugin.lang.sqf.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.a3plugin.lang.sqf.psi"
  psiImplPackage="com.kaylerrenslow.a3plugin.lang.sqf.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFTokenType"

  psiImplUtilClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.helpers.SQFPsiImplUtil"

  name("command_call")="command"
  name("return_statement")="return statement"
  name("try_catch")="try-catch block"
  name("config_expression")="config expression"
  name("bool_expression")="bool expression"

}
// @formatter:off
sqfFile ::= sqfContent_

private sqfContent_ ::= item_* return_statement? (whitespace_comment_ | BAD_CHARACTER)*

private item_ ::= whitespace_comment_ | statement | BAD_CHARACTER
private whitespace_comment_ ::= WHITE_SPACE | comment_
private comment_ ::= COMMENT | BLOCK_COMMENT | COMMENT_KEYWORD STRING_LITERAL
variable ::= (GLOBAL_VAR | LOCAL_VAR) | LANG_VAR {mixin="com.kaylerrenslow.a3plugin.lang.sqf.psi.impl.SQFNamedElementImpl" implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFNamedElement" methods=[]}


statement ::= ( assignment
				| command_call
				| private_decl
				| scope_manager
				| control_struct
				| try_catch
			  ) SEMICOLON

return_statement ::= (config_expression | bool_expression | add_expression) SEMICOLON?

assignment ::= variable EQ (assignment | expression | switch_statement | if_statement | code_block)

expression ::= config_expression | add_expression | bool_expression

//expression2_ ::= expression  {extends="expression"}

config_expression ::= value ((GTGT | FSLASH) config_expression)+

bool_expression ::= bool_group_expression

bool_group_expression ::= bool_comp_expression ((AND | AMPAMP | OR | BARBAR) bool_expression)*

bool_comp_expression ::= (EXCL | NOT) (bool_term)
					   | ASSERT LPAREN bool_expression RPAREN
					   | bool_test_expression

bool_test_expression ::= add_expression EQEQ add_expression //==
					   | add_expression NE add_expression //!=
					   | add_expression LT add_expression // <
					   | add_expression GT add_expression // >
					   | add_expression LE add_expression // <=
					   | add_expression GE add_expression // >=
					   | bool_term

bool_term ::= command_call
			| variable
			| TRUE
			| FALSE
			| LPAREN (bool_expression) RPAREN

//private bool_expression_paren ::=

add_expression ::= mult_expression PLUS add_expression
				 | mult_expression MINUS add_expression
				 | mult_expression

mult_expression ::= value ASTERISK mult_expression
				  | value FSLASH mult_expression
				  | value PERC mult_expression
				  | value MOD mult_expression
				  | value CARET mult_expression
				  | value

value ::= (PLUS | MINUS)? (
			command_call
			| terminal_
			| LPAREN expression RPAREN
		   )

private command_call_pre_argument ::= (PLUS | MINUS)? (
										terminal_
										| LPAREN expression RPAREN
									   )

private terminal_ ::= STRING_LITERAL
					| variable
					| INTEGER_LITERAL
					| array_val
					| DEC_LITERAL
					| TRUE
					| FALSE
					| CONFIG
					| TYPE_NULL
					| NIL
					| NAMESPACE
					| LPAREN terminal_ RPAREN //necessary for command_call for prefix argument

array_val ::= LBRACKET (expression (COMMA expression)*)? RBRACKET

command_call ::= (command_call_pre_argument)? COMMAND code_block
			   | (command_call_pre_argument)? COMMAND (value)? //{mixin="com.kaylerrenslow.a3plugin.lang.sqf.psi.impl.SQFNamedElementImpl" implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFNamedElement" methods=[getCommandName]}

code_block ::= LBRACE sqfContent_ RBRACE

/*control structures and other things*/
    private_decl ::= PRIVATE (STRING_LITERAL | LBRACKET (STRING_LITERAL (COMMA STRING_LITERAL)*) RBRACKET)

    scope_manager ::= GOTO COLON STRING_LITERAL
				    | BREAK_TO STRING_LITERAL
				    | expression? BREAK_OUT STRING_LITERAL
				    | CONTINUE
				    | BREAK
				    | SCOPE_NAME STRING_LITERAL

    control_struct ::= if_statement | switch_statement | loop_ | wait_until_statement | with_statement | quest_statement
    if_statement ::= IF LPAREN bool_expression RPAREN (
				     THEN code_block (ELSE code_block)?
				   | EXIT_WITH code_block
				   | THROW value
			      )

    switch_statement ::= SWITCH (LPAREN bool_expression RPAREN | bool_expression) DO LBRACE (switch_case)* RBRACE
    switch_case ::= (CASE value COLON code_block SEMICOLON)
				  | (DEFAULT code_block SEMICOLON)

    private loop_ ::= loop_while | for_loops_
    loop_while    ::= WHILE LBRACE bool_expression RBRACE DO code_block
    private for_loops_ ::= loop_for | loop_for_from | loop_for_each
    loop_for  ::= FOR LBRACKET code_block COMMA LBRACE bool_expression RBRACE COMMA code_block RBRACKET DO code_block
    loop_for_from ::= FOR STRING_LITERAL FROM expression TO expression (STEP expression)? DO code_block
    loop_for_each ::= code_block FOR_EACH expression

    quest_statement ::= QUEST bool_expression COLON exp

    try_catch ::= TRY code_block CATCH code_block

    wait_until_statement ::= WAIT_UNTIL code_block

    with_statement ::= WITH NAMESPACE DO code_block
