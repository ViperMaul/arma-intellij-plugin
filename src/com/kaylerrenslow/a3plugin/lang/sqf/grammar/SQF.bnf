{
  parserClass="com.kaylerrenslow.a3plugin.lang.sqf.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.a3plugin.lang.sqf.psi"
  psiImplPackage="com.kaylerrenslow.a3plugin.lang.sqf.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFTokenType"

  psiImplUtilClass="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFPsiImplUtilForGrammar"

  name("return_statement")="Return Statement"
  name("try_catch")="try-catch block"
  name("macro_call")="Macro Call"
  name("assignment")="Assignment"
  name("if_statement")="If Statement"
  name("expression")="Expression"
  name("terminal_")="Terminal"
  name("exp_operand_")="Terminal"

}
// @formatter:off
sqfFile ::= file_scope //need both file_scope and scope or sqfFile will be discarded

file_scope ::= return_statement | item_+ return_statement? (comment | BAD_CHARACTER)* {extends("file_scope")=local_scope}
local_scope ::= return_statement | item_+ return_statement? (comment | BAD_CHARACTER)* {implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.SQFScope" methods=[getPrivateDeclaredVars]}

private item_ ::= comment | statement | BAD_CHARACTER

comment ::= INLINE_COMMENT | BLOCK_COMMENT | COMMENT_COMMAND
variable ::= GLOBAL_VAR | LOCAL_VAR | LANG_VAR {mixin="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFVariableNamedElementMixin" implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFVariableNamedElement" methods=[followsSQFFunctionNameRules getDeclarationScope]}


statement ::= ( assignment
                | params_statement
				| private_decl
				| scope_manager
				| control_struct_
				| try_catch
				| expression
			  ) SEMICOLON

return_statement ::= expression SEMICOLON?

assignment ::= variable EQ (expression | switch_statement | if_statement | code_block) {methods=[getAssigningVariable]}

expression::= exp_operand_ exp_operator_ expression | exp_operand_
private exp_operand_ ::= (PLUS | MINUS | NOT | EXCL)? (macro_call | terminal_ COMMAND exp_operand_? | COMMAND exp_operand_ | COMMAND | terminal_)
                       | code_block
                       | ASSERT LPAREN expression RPAREN

private exp_operator_ ::= PLUS
                        | MINUS

                        | ASTERISK
                        | FSLASH
                        | PERC
                        | MOD
                        | CARET

                        | AND
                        | AMPAMP
                        | OR
                        | BARBAR

                        | EXCL
                        | NOT
                        | EQEQ
                        | NE
                        | LT
                        | GT
                        | LE
                        | GE

                        | GTGT


private terminal_ ::= string
					| variable
					| INTEGER_LITERAL
					| array_val
					| DEC_LITERAL
					| TRUE
					| FALSE
					| CONFIG
					| TYPE_NULL
					| NIL
					| NAMESPACE
					| LPAREN expression RPAREN

string ::= STRING_LITERAL {mixin="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFStringMixin" methods=[getNonQuoteText]}

macro_call ::= variable LPAREN expression (COMMA expression)* RPAREN

array_val ::= LBRACKET (expression (COMMA expression)*)? RBRACKET


code_block ::= LBRACE local_scope? RBRACE

/*control structures and other things*/
    private_decl ::= PRIVATE ( private_decl_var | LBRACKET (private_decl_var (COMMA private_decl_var)*) RBRACKET) {methods=[getPrivateDeclVars]}//do not allow private[]

    params_statement ::= array_val? PARAMS LBRACKET (params_param_ (COMMA params_param_)*) RBRACKET
    private params_param_ ::= LBRACKET private_decl_var (COMMA expression)* RBRACKET | private_decl_var

	//DO NOT CHANGE STRING_LITERAL IN private_decl_var to string
	private_decl_var ::= STRING_LITERAL {mixin="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFPrivateDeclVarMixin" implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFPrivateDeclNamedElement" methods=[toString]}
	//private_decl_var is a variable that designates the variable as private


    scope_manager ::= GOTO COLON string
				    | BREAK_TO string
				    | expression? BREAK_OUT string
				    | CONTINUE
				    | BREAK
				    | SCOPE_NAME string

    private control_struct_ ::= if_statement | switch_statement | loop_ | wait_until_statement | with_statement | quest_statement
    if_statement ::= IF LPAREN expression RPAREN (
				     THEN code_block (ELSE code_block)?
				   | EXIT_WITH code_block
				   | THROW value
			      )

    switch_statement ::= SWITCH (LPAREN expression RPAREN | expression) DO LBRACE (switch_case)* RBRACE
    switch_case ::= (CASE expression (COLON code_block)? SEMICOLON)
				  | (DEFAULT code_block SEMICOLON)

    private loop_ ::= loop_while | for_loops_
    loop_while    ::= WHILE LBRACE assignments_or_exppresion_ RBRACE DO code_block
    private for_loops_ ::= loop_for | loop_for_from | loop_for_each
    loop_for  ::= FOR LBRACKET LBRACE (for_loop_iter_var_init)* RBRACE COMMA LBRACE expression RBRACE COMMA LBRACE (statement)* RBRACE RBRACKET DO code_block {methods=[getIterationVariables getLoopScope] implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFForLoopBase" }
    loop_for_from ::= FOR string FROM expression TO expression (STEP expression)? DO code_block {methods=[getIterationVariables getLoopScope] implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFForLoopBase" }
    loop_for_each ::= code_block FOR_EACH expression  {methods=[getIterationVariables getLoopScope] implements="com.kaylerrenslow.a3plugin.lang.sqf.psi.mixin.SQFForLoopBase" }

    for_loop_iter_var_init ::= statement

    private assignments_or_exppresion_ ::= (assignment SEMICOLON)* expression?

    quest_statement ::= QUEST expression COLON exp

    try_catch ::= TRY code_block CATCH code_block

    wait_until_statement ::= WAIT_UNTIL code_block

    with_statement ::= WITH NAMESPACE DO code_block
