{
  parserClass="com.kaylerrenslow.plugin.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.plugin.psi"
  psiImplPackage="com.kaylerrenslow.plugin.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.plugin.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.plugin.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.plugin.psi.SQFTokenType"
}
// @formatter:off
sqfFile ::= item_* (returnStatement_)?

private ignore_ ::= WHITE_SPACE | comment_
private item_ ::= ignore_ | statement_ | BAD_CHARACTER

private identifier_ ::= LOCAL_VAR | IDENTIFIER | LANG_CONSTANT | LPAREN identifier_ RPAREN

private comment_ ::= COMMENT | COMMENT_KEYWORD STRING_LITERAL

literal_ ::= STRING_LITERAL | INTEGER_LITERAL | DEC_LITERAL

//TODO inside format String's, turn %x blue
//TODO hintSilent parseText (localize _this);
//TODO remove the commands that are specific

private statement_ ::= (
                        exp_
                        | private_declaration_
                        | controlStructure_
                        | scopeManager_
                        | tryCatch_
                        | EXIT
                     ) SEMICOLON

private returnStatement_ ::= (commandExpOrValue_ | conditionalExp_) SEMICOLON? (ignore_ | BAD_CHARACTER)*
private codeBlock_ ::= LBRACE RBRACE | LBRACE (item_)+ (returnStatement_)? RBRACE

private exp_ ::= assignmentExp_
               | commandExpOrValue_

private exp2_ ::= LPAREN exp_ RPAREN | exp_

private assignmentExp_ ::= identifier_ EQ (commandExpOrValue_ | mathExp_ | switchStatement_ | ifStatement_ | assignmentExp_ | conditionalExp_)

private condition_ ::= TRUE | FALSE | commandExpOrValue_
private conditionStandalone_ ::= TRUE | FALSE | commandExp_ | identifier_
private conditionalExpPart_ ::= EXCL condition_
                              | NOT condition_
                              | ( condition_ (
                                               AMPAMP
                                              | AND
                                              | BARBAR
                                              | OR
                                              | EQEQ
                                              | NE
                                              | LT
                                              | GT
                                              | LE
                                              | GE
                                             ) condition_
                                )
                              | ASSERT LPAREN conditionalExpPart_ RPAREN
                              | LPAREN conditionalExpPart_ RPAREN
                              | conditionStandalone_


private conditionalExp_ ::= conditionalExpPart_ (AND | AMPAMP) conditionalExpPart_
                          | conditionalExpPart_ (OR | BARBAR) conditionalExpPart_
                          | conditionalExpPart_


private commandExp_ ::= DISABLE_SERIALIZATION
                      | commandStr_
                      | commandHintExp_
                      | commandFormatExp_
                      | commandThrow_
                      | commandCompile_
                      | commandCodeExecs_
                      | commandWithExp_
                      | localizeCommandExp_
                      | (value_)? COMMAND LPAREN commandExpOrValue_ RPAREN
                      | (value_)? COMMAND (commandExpOrValue_)?
                      | (value_)? COMMAND codeBlock_
                      | LPAREN commandExp_ RPAREN

private mathOp_ ::= PLUS | MINUS | ASTERISK | CARET | PERC | MOD | FSLASH
private mathExp_ ::= LPAREN mathExp_ RPAREN
                   | commandExpOrValue_ mathOp_ mathExpRhs_

private mathExpRhs_ ::= commandExpOrValue_ mathOp_ mathExpRhs_ | commandExpOrValue_

/*VALUES*/
    private value_ ::= identifier_ | literal_ | arrayVal_ | configVal_ | TYPE_NULL | NIL | TRUE | FALSE | LPAREN value_ RPAREN
    private commandExpOrValue_ ::= commandExp_ | value_ ; /*commandExp must go first since some commands match value_ for their pre-params ("arr select 1" -> arr is pre-param)*/

    private arrayVal_  ::= LBRACKET RBRACKET | LBRACKET exp2_ (COMMA exp2_)* RBRACKET

    private configVal_ ::= CONFIG
                         | CONFIG FSLASH (STRING_LITERAL | identifier_) (FSLASH (STRING_LITERAL | identifier_))*
                         | CONFIG GTGT (STRING_LITERAL | identifier_) (GTGT (STRING_LITERAL | identifier_))*

    private localizedStrVal_ ::= localizeCommandExp_ | STRING_LITERAL


/*CONTROL STRUCTURES AND OTHER THINGS*/
    private private_declaration_ ::= PRIVATE (STRING_LITERAL | LBRACKET (STRING_LITERAL (COMMA STRING_LITERAL)*) RBRACKET)

    private scopeManager_ ::= GOTO COLON STRING_LITERAL
                            | BREAK_TO STRING_LITERAL
                            | commandExpOrValue_? BREAK_OUT STRING_LITERAL
                            | CONTINUE
                            | BREAK
                            | SCOPE_NAME STRING_LITERAL

    private controlStructure_ ::= ifStatement_ | switchStatement_ | loop_ | waitUntil_ | quest_
    private ifStatement_ ::= IF LPAREN conditionalExp_ RPAREN (
                              THEN codeBlock_ (ELSE codeBlock_)?
                              | EXIT_WITH codeBlock_
                              | commandThrow_
                           )

    private switchStatement_ ::= SWITCH (LPAREN commandExpOrValue_ RPAREN | commandExpOrValue_) DO LBRACE (switchCase_)* RBRACE
    private switchCase_ ::= (CASE value_ COLON codeBlock_ SEMICOLON)
                          | (DEFAULT codeBlock_ SEMICOLON)

    private loop_ ::= whileLoop_ | forLoop_
    private whileLoop_   ::= WHILE LBRACE conditionalExp_ RBRACE DO codeBlock_
    private forLoop_     ::= forLoopReg_ | forLoopFrom_ | forEachLoop_
    private forLoopReg_  ::= FOR LBRACKET codeBlock_ COMMA LBRACE exp2_ RBRACE COMMA codeBlock_ RBRACKET DO codeBlock_
    private forLoopFrom_ ::= FOR STRING_LITERAL FROM exp2_ TO exp2_ (STEP exp2_)? DO codeBlock_
    private forEachLoop_ ::= codeBlock_ FOR_EACH exp2_

    private quest_ ::= QUEST conditionalExp_ COLON commandExpOrValue_

    private tryCatch_ ::= TRY codeBlock_ CATCH codeBlock_ /*_exception is predefined in catch block*/

    private waitUntil_ ::= WAIT_UNTIL codeBlock_


/*COMMANDS*/
    private commandThrow_ ::= THROW value_
    private commandWithExp_ ::= WITH NAMESPACE DO codeBlock_

    private commandCodeExecs_ ::= value_? CALL func_
                                | value_? EXEC_VM func_
                                | value_? SPAWN func_
                                | STRING_LITERAL CALL_EXTENSION value_
                                | value_? EXEC value_
                                | value_? EXEC_FSM value_
                                | value_ EXEC_EDITOR_SCRIPT arrayVal_
                                | LPAREN commandCodeExecs_ RPAREN

    private func_ ::= commandCompile_
                    | codeBlock_
                    | identifier_
                    | codeString_

    private commandCompile_ ::= (COMPILE_FINAL | COMPILE) (codeString_ | LPAREN codeString_ RPAREN)

    private codeString_ ::= PREPROCESS_FILE value_
                          | LOAD_FILE value_
                          | STRING_LITERAL

    private commandHintExp_ ::= HINT (identifier_ | commandStr_ | localizeCommandExp_ | commandFormatExp_ | commandCodeExecs_) //sqf won't allow any value except strings to be hinted directly. other values must pass the format command

    private commandFormatExp_ ::= FORMAT LBRACKET (localizeCommandExp_ | identifier_ | localizedStrVal_) (COMMA commandExpOrValue_)* RBRACKET /*format doesn't *require* params beyond the String literal*/

    private commandStr_ ::= STR exp2_

    private localizable_ ::= (identifier_ | STRING_LITERAL)
    private localizeCommandExp_ ::= LOCALIZE (localizable_ | LPAREN localizable_ RPAREN)

/*
private commandAppendExp_ ::= value_ APPEND value_
private commandSetExp_ ::= value_ SET LBRACKET value_ COMMA value_ RBRACKET
private commandCountExp_ ::= value_? COUNT value_
private commandFindExp_ ::= commandExpOrValue_ FIND commandExpOrValue_
private commandParam_ ::= arrayVal_? (PARAM | PARAMS) arrayVal_
private commandSelectExp_ ::= value_ SELECT value_
                            | value_ SELECT LBRACKET value_ COMMA value_ RBRACKET

private commandConfigClassesExp_ ::= value_ CONFIG_CLASSES (configVal_ | LPAREN configVal_ RPAREN)

