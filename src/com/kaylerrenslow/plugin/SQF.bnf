{
  parserClass="com.kaylerrenslow.plugin.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.plugin.psi"
  psiImplPackage="com.kaylerrenslow.plugin.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.plugin.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.plugin.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.plugin.psi.SQFTokenType"
}
// @formatter:off
sqfFile ::= item_*

private item_ ::= WHITE_SPACE | comment_ | statement_ | BAD_CHARACTER

private identifier_ ::= LOCAL_VAR | IDENTIFIER | LANG_CONSTANT

private integer_ ::= MINUS? INTEGER_LITERAL
private decimal_ ::= MINUS? DEC_LITERAL

private comment_ ::= COMMENT | COMMENT_KEYWORD STRING_LITERAL

literal ::= STRING_LITERAL | integer_ | decimal_

private unusedLexerKeywords_ ::= GTGT | TYPE_NULL | NIL | LANG_CONSTANT | NAMESPACE

private statement_ ::= (
                        exp_
                        | private_declaration_
                        | controlStructure_
                        | scopeManager_
                        | tryCatch_
                        | EXIT
                     ) SEMICOLON

private code_ ::= LBRACE RBRACE | LBRACE (item_)+ RBRACE

private exp_ ::= assignmentExp_
               | commandExp_
               | valueExp_ /*this needs to be after commandExp_, otherwise [] spawn {...} will break because it is expecting [] to be the returning value*/

private assignmentExp_ ::= identifier_ EQ exp_

private conditionalExp_ ::= TRUE | FALSE
                          | EXCL comparableVal_
                          | NOT comparableVal_
                          | comparableVal_ AMPAMP comparableVal_
                          | comparableVal_ AND comparableVal_
                          | comparableVal_ BARBAR comparableVal_
                          | comparableVal_ OR comparableVal_
                          | comparableVal_ EQEQ comparableVal_
                          | comparableVal_ NE comparableVal_
                          | comparableVal_ LT comparableVal_
                          | comparableVal_ GT comparableVal_
                          | comparableVal_ LE comparableVal_
                          | comparableVal_ GE comparableVal_
                          | ASSERT LPAREN conditionalExp_ RPAREN

private comparableVal_ ::= commandExpOrValueExp | (LPAREN conditionalExp_ RPAREN)

private commandExp_ ::= DISABLE_SERIALIZATION
                      /*| commandParam_
                      | commandCodeExec_
                      | commandSelectExp_
                      | codeCompile_
                      | commandHintExp_
                      | commandFormatExp_
                      | commandCountExp_
                      | commandSetExp_
                      | CONFIG_NAME configVal_ /*example: missionConfigFile >> "test"*/
                      /*| commandConfigClassesExp_
                      | commandAppendExp_
                      | commandFindExp_
                      | commandWithExp_
                      | commandThrow_*/
                      | codeExec_
                      | commandWithExp_
                      //| (valueExp_)* COMMAND LPAREN (valueExp_ | COMMAND)* RPAREN
                      | (valueExp_ | COMMAND)* COMMAND (valueExp_ | COMMAND)*
                      | LPAREN commandExp_ RPAREN

private mathExp_ ::= LPAREN mathExp_ RPAREN
                   | commandExpOrValueExp PLUS mathExpRhs_
                   | commandExpOrValueExp MINUS mathExpRhs_
                   | commandExpOrValueExp ASTERISK mathExpRhs_
                   | commandExpOrValueExp CARET mathExpRhs_
                   | commandExpOrValueExp PERC mathExpRhs_
                   | commandExpOrValueExp MOD mathExpRhs_
                   | commandExpOrValueExp FSLASH mathExpRhs_

private mathExpRhs_ ::= (commandExpOrValueExp | mathExp_)

/*begin value exps*/

private valueExp_ ::= identifier_ | literal | arrayVal_ | configVal_ | LPAREN valueExp_ RPAREN
private commandExpOrValueExp ::= commandExp_ | valueExp_ ; /*commandExp must go first since some commands match valueExp_ for their pre-params ("arr select 1" -> arr is pre-param)*/

private arrayVal_  ::= LBRACKET RBRACKET | LBRACKET exp_ (COMMA exp_)* RBRACKET

private configVal_ ::= CONFIG
                     | CONFIG FSLASH (STRING_LITERAL | identifier_) (FSLASH (STRING_LITERAL | identifier_))*
                     | CONFIG GTGT (STRING_LITERAL | identifier_) (GTGT (STRING_LITERAL | identifier_))*

/*end value exps*/


private private_declaration_ ::= PRIVATE LBRACKET ((identifier_ (COMMA identifier_)*) | (STRING_LITERAL (COMMA STRING_LITERAL)*)) RBRACKET

private scopeManager_ ::= GOTO COLON STRING_LITERAL
                        | BREAK_TO STRING_LITERAL
                        | commandExpOrValueExp? BREAK_OUT STRING_LITERAL
                        | CONTINUE
                        | BREAK
                        | SCOPE_NAME STRING_LITERAL

/* begin control structures*/
private controlStructure_ ::= ifStatement_ | switchStatement_ | loop_ | quest_
private ifStatement_ ::= IF LPAREN conditionalExp_ RPAREN (
                          THEN code_ (ELSE code_)?
                          | EXIT_WITH code_
                          | commandThrow_
                       )
private switchStatement_ ::= SWITCH LPAREN identifier_ RPAREN DO LBRACE (switchCase_)* RBRACE
private switchCase_ ::= (CASE valueExp_ COLON code_ SEMICOLON)
                     | (DEFAULT code_ SEMICOLON)
private loop_ ::= whileLoop_ | forLoop_
private whileLoop_   ::= WHILE LBRACE conditionalExp_ RBRACE DO code_
private forLoop_     ::= forLoopReg_ | forLoopFrom_ | forEachLoop_
private forLoopReg_  ::= FOR LBRACKET code_ COMMA LBRACE exp_ RBRACE COMMA code_ RBRACKET DO code_
private forLoopFrom_ ::= FOR STRING_LITERAL FROM exp_ TO exp_ (STEP exp_)? DO code_
private forEachLoop_ ::= code_ FOR_EACH exp_
private quest_ ::= QUEST conditionalExp_ COLON conditionalExp_

private tryCatch_ ::= TRY code_ CATCH code_
/*end control structures*/


private commandThrow_ ::= THROW valueExp_
private commandWithExp_ ::= WITH NAMESPACE DO code_

private codeExec_ ::= valueExp_? CALL func_
                    | valueExp_? EXEC_VM func_
                    | valueExp_? SPAWN func_
                    | STRING_LITERAL CALL_EXTENSION valueExp_
                    | valueExp_? EXEC valueExp_
                    | valueExp_? EXEC_FSM valueExp_
                    | valueExp_ EXEC_EDITOR_SCRIPT arrayVal_


private func_ ::= codeCompile_
                | code_
                | codeString_

private codeString_ ::= PREPROCESS_FILE valueExp_
                      | LOAD_FILE valueExp_
                      | valueExp_

private codeCompile_ ::= COMPILE codeString_
                       | COMPILE_FINAL codeString_
/*
private commandAppendExp_ ::= valueExp_ APPEND valueExp_
private commandSetExp_ ::= valueExp_ SET LBRACKET valueExp_ COMMA valueExp_ RBRACKET
private commandCountExp_ ::= valueExp_? COUNT valueExp_
private commandFindExp_ ::= commandExpOrValueExp FIND commandExpOrValueExp
private commandParam_ ::= arrayVal_? (PARAM | PARAMS) arrayVal_
private commandHintExp_ ::= HINT (valueExp_ | commandFormatExp_)
                          | HINT_C (valueExp_ | commandFormatExp_)
                          | HINT_SILENT (valueExp_ | commandFormatExp_)

private commandFormatExp_ ::= FORMAT LBRACKET STRING_LITERAL COMMA valueExp_ (COMMA valueExp_)* RBRACKET
private commandSelectExp_ ::= valueExp_ SELECT valueExp_
                            | valueExp_ SELECT LBRACKET valueExp_ COMMA valueExp_ RBRACKET

private commandConfigClassesExp_ ::= valueExp_ CONFIG_CLASSES (configVal_ | LPAREN configVal_ RPAREN)


// @formatter:on