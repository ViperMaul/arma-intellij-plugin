{
  parserClass="com.kaylerrenslow.plugin.lang.sqf.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.plugin.lang.sqf.psi"
  psiImplPackage="com.kaylerrenslow.plugin.lang.sqf.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFTokenType"
}
// @formatter:off
sqfFile ::= sqfContent_

private sqfContent_ ::= item_* return_statement? (whitespace_comment_ | BAD_CHARACTER)*

private item_ ::= whitespace_comment_ | statement | BAD_CHARACTER
private whitespace_comment_ ::= WHITE_SPACE | comment_
private comment_ ::= COMMENT | COMMENT_KEYWORD STRING_LITERAL
private identifier_ ::= IDENTIFIER | LOCAL_VAR | LANG_CONSTANT

statement ::= ( assignment
				| command_call
				| private_decl
				| scope_manager
				| control_struct
				| try_catch
			  ) SEMICOLON

return_statement ::= expression SEMICOLON?

assignment ::= identifier_ EQ (assignment | expression | switch_statement | if_statement | code_block)

expression ::= config_expression | add_expression | bool_expression

config_expression ::= value ((GTGT | FSLASH) expression)+

bool_expression ::= bool_group_expression
				  | bool_comp_expression
				  | value
				  | LPAREN bool_expression RPAREN

bool_comp_expression ::= add_expression EQEQ bool_expression //==
				  | add_expression NE bool_expression //!=
				  | add_expression LT add_expression // <
				  | add_expression GT add_expression // >
				  | add_expression LE add_expression // <=
				  | add_expression GE add_expression // >=
				  | EXCL bool_expression //!
				  | NOT bool_expression //not
				  | ASSERT LPAREN bool_expression RPAREN

bool_group_expression ::= bool_comp_expression ((AND | AMPAMP | OR | BARBAR) bool_comp_expression)+

add_expression ::= mult_expression PLUS add_expression
				 | mult_expression MINUS add_expression
				 | mult_expression

mult_expression ::= value ASTERISK mult_expression
				  | value FSLASH mult_expression
				  | value PERC mult_expression
				  | value MOD mult_expression
				  | value CARET mult_expression
				  | value

value ::= (PLUS | MINUS)? (
			command_call
			| terminal_
			| LPAREN expression RPAREN
		  )

private terminal_ ::= STRING_LITERAL
					| identifier_
					| INTEGER_LITERAL
					| array_val
					| DEC_LITERAL
					| TRUE
					| FALSE
					| CONFIG
					| TYPE_NULL
					| NIL
					| NAMESPACE
					| LPAREN terminal_ RPAREN //necessary for command_call for prefix argument

array_val ::= LBRACKET (expression (COMMA expression)*)? RBRACKET

command_call ::= (terminal_)? COMMAND code_block
			   | (terminal_)? COMMAND (value)?

code_block ::= LBRACE sqfContent_ RBRACE

/*control structures and other things*/
    private_decl ::= PRIVATE (STRING_LITERAL | LBRACKET (STRING_LITERAL (COMMA STRING_LITERAL)*) RBRACKET)

    scope_manager ::= GOTO COLON STRING_LITERAL
				    | BREAK_TO STRING_LITERAL
				    | expression? BREAK_OUT STRING_LITERAL
				    | CONTINUE
				    | BREAK
				    | SCOPE_NAME STRING_LITERAL

    control_struct ::= if_statement | switch_statement | loop_ | wait_until_statement | with_statement | quest_statement
    if_statement ::= IF LPAREN bool_expression RPAREN (
				     THEN code_block (ELSE code_block)?
				   | EXIT_WITH code_block
				   | THROW value
			      )

    switch_statement ::= SWITCH (LPAREN bool_expression RPAREN | bool_expression) DO LBRACE (switch_case)* RBRACE
    switch_case ::= (CASE value COLON code_block SEMICOLON)
				  | (DEFAULT code_block SEMICOLON)

    private loop_ ::= loop_while | for_loops_
    loop_while    ::= WHILE LBRACE bool_expression RBRACE DO code_block
    private for_loops_ ::= loop_for | loop_for_from | loop_for_each
    loop_for  ::= FOR LBRACKET code_block COMMA LBRACE expression RBRACE COMMA code_block RBRACKET DO code_block
    loop_for_from ::= FOR STRING_LITERAL FROM expression TO expression (STEP expression)? DO code_block
    loop_for_each ::= code_block FOR_EACH expression

    quest_statement ::= QUEST bool_expression COLON exp

    try_catch ::= TRY code_block CATCH code_block

    wait_until_statement ::= WAIT_UNTIL code_block

    with_statement ::= WITH NAMESPACE DO code_block
