{
  parserClass="com.kaylerrenslow.plugin.lang.sqf.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.plugin.lang.sqf.psi"
  psiImplPackage="com.kaylerrenslow.plugin.lang.sqf.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFTokenType"
}
// @formatter:off
sqfFile ::= item_* (returnStatement)?

private item_ ::= whitespace_comment_ | statement | BAD_CHARACTER

private whitespace_comment_ ::= WHITE_SPACE | comment_

variable ::= LOCAL_VAR | IDENTIFIER | LANG_CONSTANT | LPAREN variable RPAREN

private comment_ ::= COMMENT | COMMENT_KEYWORD STRING_LITERAL

private literal_ ::= STRING_LITERAL | (MINUS | PLUS)? INTEGER_LITERAL | (MINUS | PLUS)? DEC_LITERAL

//TODO allow copy of arrays: _test=+[0,1]
//TODO support #define


statement ::= ( assignment
			| commandExp
			| privateDeclaration
			| controlStructure
			| scopeManager
			| tryCatch
		 ) SEMICOLON

assignment ::= variable EQ ( (exp | codeBlock | assignment) | (switchStatement | ifStatement ) )

returnStatement ::= (commandExpOrValueExp | conditionalExp) SEMICOLON? (whitespace_comment_ | BAD_CHARACTER)*

codeBlock ::= LBRACE RBRACE | LBRACE (item_)* (returnStatement)? RBRACE


exp ::= LPAREN exp RPAREN
	  | configExp //must come first since CONFIG is of type value
	  | mathExp //math must come before value because math contains values before operator
	  | conditionalExp
	  | commandExp //command must come before value because commands sometimes require values prior to the command itself. For example:: [] spawn {}
	  | valueExp


/*conditionalExp*/
    condition ::= LPAREN condition RPAREN
				| mathExp //math must come before value because math contains values before operator
				| commandExpCondition_
				| valueExp

	/*
		can't use the regular commandExp because it will parse a conditionalExp and !isNull player && player == player will break.
		!isNull -> conditionalExp
		conditionalExp player && player - > conditionalExp conditionalExp (BREAKS HERE)

		The first rule is required since the normal commandExp has exp and exp can allow parens
		See -> exp ::= LPAREN exp RPAREN
	*/
	private commandExpCondition_ ::= (valueExp)? COMMAND LPAREN (configExp | mathExp | commandExpCondition_ | valueExp)? RPAREN
								   | (valueExp)? COMMAND (configExp | mathExp | commandExpCondition_ | valueExp)?

    private conditionStandalone_ ::= commandExpCondition_ | variable | TRUE | FALSE
    private conditionalOp_ ::=  AMPAMP | AND | BARBAR | OR | EQEQ | NE | LT | GT | LE | GE
    conditionalExpPart ::= ( condition conditionalOp_ condition)
						 | EXCL condition //must come after condition operator condition because ! would be preferred over != if it wasn't
						 | NOT condition
						 | ASSERT LPAREN conditionalExpPart RPAREN
						 | LPAREN conditionalExpPart RPAREN
						 | conditionStandalone_


    conditionalExp ::= conditionalExpPart ((AND | AMPAMP | OR | BARBAR) conditionalExp)*

/*commandExp*/
    commandExp ::= LPAREN commandExp RPAREN //for where exp is not used and just commandExp
				 | (valueExp)? COMMAND codeBlock //must go first after LPAREN commandExp RPAREN. for some reason, if it is before (valueExp)? COMMAND (exp)?, [] spawn {...} breaks
				 | (valueExp)? COMMAND (exp)?

/*configExp*/
    configHolder ::= CONFIG | variable | STRING_LITERAL | commandExp
    configExp ::= configHolder GTGT configHolder (GTGT configHolder)*
				| configHolder FSLASH configHolder (FSLASH configHolder)*

/*mathExp*/
	mathExp ::= MINUS? LPAREN mathExp RPAREN
		   | mathOperand_ (mathRhs_)+

    private mathOperator_ ::= PLUS | MINUS | ASTERISK | CARET | PERC | MOD | FSLASH
	private mathOperand_ ::= commandExpOrValueExp

	private mathRhs_ ::= mathOperator_ mathRhsGroup_
					   | mathOperator_ mathOperand_ mathRhs_?

	private mathRhsGroup_ ::= MINUS? LPAREN mathOperand_ (mathRhs_ | (mathOperator_ mathOperand_))+ RPAREN


/*valueExp*/
    valueExp ::= LPAREN valueExp RPAREN | variable | literal_ | arrayVal | CONFIG | TYPE_NULL | NIL | TRUE | FALSE | NAMESPACE
    commandExpOrValueExp ::= commandExp | valueExp ; /*commandExp must go first since some commands match value for their pre-params ("arr select 1" -> arr is pre-param)*/

    arrayVal ::= PLUS? LBRACKET RBRACKET
			   | PLUS? LBRACKET (exp | codeBlock) (COMMA (exp | codeBlock))* RBRACKET


/*control structures and other things*/
    privateDeclaration ::= PRIVATE (STRING_LITERAL | LBRACKET (STRING_LITERAL (COMMA STRING_LITERAL)*) RBRACKET)

    scopeManager ::= GOTO COLON STRING_LITERAL
				   | BREAK_TO STRING_LITERAL
				   | exp? BREAK_OUT STRING_LITERAL
				   | CONTINUE
				   | BREAK
				   | SCOPE_NAME STRING_LITERAL

    controlStructure ::= ifStatement | switchStatement | loop | waitUntilStatement | withStatement | questStatement
    ifStatement ::= IF LPAREN conditionalExp RPAREN (
				    THEN codeBlock (ELSE codeBlock)?
				  | EXIT_WITH codeBlock
				  | THROW valueExp
			   )

    switchStatement ::= SWITCH (LPAREN commandExpOrValueExp RPAREN | commandExpOrValueExp) DO LBRACE (switchCase)* RBRACE
    switchCase ::= (CASE valueExp COLON codeBlock SEMICOLON)
				 | (DEFAULT codeBlock SEMICOLON)

    loop ::= whileLoop | forLoop
    whileLoop   ::= WHILE LBRACE conditionalExp RBRACE DO codeBlock
    forLoop     ::= forLoopReg | forLoopFrom | forEachLoop
    forLoopReg  ::= FOR LBRACKET codeBlock COMMA LBRACE exp RBRACE COMMA codeBlock RBRACKET DO codeBlock
    forLoopFrom ::= FOR STRING_LITERAL FROM exp TO exp (STEP exp)? DO codeBlock
    forEachLoop ::= codeBlock FOR_EACH exp

    questStatement ::= QUEST conditionalExp COLON exp

    tryCatch ::= TRY codeBlock CATCH codeBlock

    waitUntilStatement ::= WAIT_UNTIL codeBlock

    withStatement ::= WITH NAMESPACE DO codeBlock
