{
  parserClass="com.kaylerrenslow.plugin.lang.sqf.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.plugin.lang.sqf.psi"
  psiImplPackage="com.kaylerrenslow.plugin.lang.sqf.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFTokenType"
}
// @formatter:off
sqfFile ::= item_* (returnStatement)?

private item_ ::= whitespace_comment_ | statement | BAD_CHARACTER

private whitespace_comment_ ::= WHITE_SPACE | comment_

variable ::= LOCAL_VAR | IDENTIFIER | LANG_CONSTANT | LPAREN variable RPAREN

private comment_ ::= COMMENT | COMMENT_KEYWORD STRING_LITERAL

private literal_ ::= STRING_LITERAL | (MINUS | PLUS)? INTEGER_LITERAL | (MINUS | PLUS)? DEC_LITERAL

//TODO allow copy of arrays: _test=+[0,1]
//TODO support #define


statement ::= ( assignment
			| commandExp
			| privateDeclaration
			| controlStructure
			| scopeManager
			| tryCatch
		 ) SEMICOLON

assignment ::= variable EQ ( (exp | codeBlock | assignment) | (switchStatement | ifStatement ) )

returnStatement ::= (commandExpOrValue | conditionalExp) SEMICOLON? (whitespace_comment_ | BAD_CHARACTER)*

codeBlock ::= LBRACE RBRACE | LBRACE (item_)* (returnStatement)? RBRACE


exp ::= LPAREN exp RPAREN
               | configExp //must come first since CONFIG is of type value
               | mathExp //math must come before value because math contains values before operator
               | conditionalExp
               | commandExp //command must come before value because commands sometimes require values prior to the command itself. For example:: [] spawn {}
               | valueExp


/*conditionalExp*/
    condition ::= LPAREN condition RPAREN
                         | mathExp //math must come before value because math contains values before operator
                         | commandExp //command must come before value because commands sometimes require values prior to the command itself. For example:: [] spawn {}
                         | valueExp

    conditionStandalone ::= commandExp | variable | TRUE | FALSE
    conditionalOp ::=  AMPAMP | AND | BARBAR | OR | EQEQ | NE | LT | GT | LE | GE
    conditionalExpPart ::= ( condition conditionalOp condition)
                                  | EXCL condition //must come after condition operator condition because ! would be preferred over != if it wasn't
                                  | NOT condition
                                  | ASSERT LPAREN conditionalExpPart RPAREN
                                  | LPAREN conditionalExpPart RPAREN
                                  | conditionStandalone


    conditionalExp ::= conditionalExpPart ((AND | AMPAMP | OR | BARBAR) conditionalExp)*

/*commandExp*/
    commandExp ::= LPAREN commandExp RPAREN //for where exp is not used and just commandExp
                          | (valueExp)? COMMAND codeBlock //must go first after LPAREN commandExp RPAREN. for some reason, if it is before (valueExp)? COMMAND (exp)?, [] spawn {...} breaks
                          | (valueExp)? COMMAND (exp)?

/*configExp*/
    configHolder ::= CONFIG | variable | STRING_LITERAL | commandExp
    configExp ::= configHolder GTGT configHolder (GTGT configHolder)*
                         | configHolder FSLASH configHolder (FSLASH configHolder)*

/*mathExp*/
    mathOp ::= PLUS | MINUS | ASTERISK | CARET | PERC | MOD | FSLASH
    mathExp ::= commandExpOrValue mathOp mathRhs

    mathRhs ::= LPAREN mathRhs RPAREN
					   | (commandExpOrValue mathOp mathRhs)+
                       | commandExpOrValue

/*valueExp*/
    valueExp ::= variable | literal_ | arrayVal | CONFIG | TYPE_NULL | NIL | TRUE | FALSE | NAMESPACE
    commandExpOrValue ::= commandExp | valueExp ; /*commandExp must go first since some commands match value for their pre-params ("arr select 1" -> arr is pre-param)*/

    arrayVal ::= PLUS? LBRACKET RBRACKET
                        | PLUS? LBRACKET (exp | codeBlock) (COMMA (exp | codeBlock))* RBRACKET


/*control structures and other things*/
    privateDeclaration ::= PRIVATE (STRING_LITERAL | LBRACKET (STRING_LITERAL (COMMA STRING_LITERAL)*) RBRACKET)

    scopeManager ::= GOTO COLON STRING_LITERAL
                            | BREAK_TO STRING_LITERAL
                            | exp? BREAK_OUT STRING_LITERAL
                            | CONTINUE
                            | BREAK
                            | SCOPE_NAME STRING_LITERAL

    controlStructure ::= ifStatement | switchStatement | loop | waitUntilStatement | withStatement | questStatement
    ifStatement ::= IF LPAREN conditionalExp RPAREN (
                              THEN codeBlock (ELSE codeBlock)?
                              | EXIT_WITH codeBlock
                              | THROW valueExp
                           )

    switchStatement ::= SWITCH (LPAREN commandExpOrValue RPAREN | commandExpOrValue) DO LBRACE (switchCase)* RBRACE
    switchCase ::= (CASE valueExp COLON codeBlock SEMICOLON)
                          | (DEFAULT codeBlock SEMICOLON)

    loop ::= whileLoop | forLoop
    whileLoop   ::= WHILE LBRACE conditionalExp RBRACE DO codeBlock
    forLoop     ::= forLoopReg | forLoopFrom | forEachLoop
    forLoopReg  ::= FOR LBRACKET codeBlock COMMA LBRACE exp RBRACE COMMA codeBlock RBRACKET DO codeBlock
    forLoopFrom ::= FOR STRING_LITERAL FROM exp TO exp (STEP exp)? DO codeBlock
    forEachLoop ::= codeBlock FOR_EACH exp

    questStatement ::= QUEST conditionalExp COLON exp

    tryCatch ::= TRY codeBlock CATCH codeBlock

    waitUntilStatement ::= WAIT_UNTIL codeBlock

    withStatement ::= WITH NAMESPACE DO codeBlock
