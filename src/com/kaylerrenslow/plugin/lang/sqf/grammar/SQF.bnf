{
  parserClass="com.kaylerrenslow.plugin.lang.sqf.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.plugin.lang.sqf.psi"
  psiImplPackage="com.kaylerrenslow.plugin.lang.sqf.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFTokenType"
}
// @formatter:off
sqfFile ::= item_* (returnStatement_)?

private item_ ::= whitespace_comment_ | statement_ | BAD_CHARACTER

private whitespace_comment_ ::= WHITE_SPACE | comment_

private identifier_ ::= LOCAL_VAR | IDENTIFIER | LANG_CONSTANT | LPAREN identifier_ RPAREN

private comment_ ::= COMMENT | COMMENT_KEYWORD STRING_LITERAL

literal_ ::= STRING_LITERAL | (MINUS | PLUS)? INTEGER_LITERAL | (MINUS | PLUS)? DEC_LITERAL

//TODO allow copy of arrays: _test=+[0,1]
//TODO support #define


private statement_ ::= (
                        assignment_
                        | commandExp_
                        | private_declaration_
                        | controlStructure_
                        | scopeManager_
                        | tryCatch_
                     ) SEMICOLON

private assignment_ ::= identifier_ EQ ( (exp_ | codeBlock_ | assignment_) | (switchStatement_ | ifStatement_ ) )

private returnStatement_ ::= (commandExpOrValue_ | conditionalExp_) SEMICOLON? (whitespace_comment_ | BAD_CHARACTER)*

private codeBlock_ ::= LBRACE RBRACE | LBRACE (item_)* (returnStatement_)? RBRACE


private exp_ ::= LPAREN exp_ RPAREN
               | configExp_ //must come first since CONFIG is of type value_
               | mathExp_ //math must come before value because math contains values before operator
               | conditionalExp_
               | commandExp_ //command must come before value because commands sometimes require values prior to the command itself. For example:: [] spawn {}
               | valueExp_


/*conditionalExp_*/
    private condition_ ::= LPAREN condition_ RPAREN
                         | mathExp_ //math must come before value because math contains values before operator
                         | commandExp_ //command must come before value because commands sometimes require values prior to the command itself. For example:: [] spawn {}
                         | valueExp_

    private conditionStandalone_ ::= commandExp_ | identifier_ | TRUE | FALSE
    private conditionalOp_ ::=  AMPAMP | AND | BARBAR | OR | EQEQ | NE | LT | GT | LE | GE
    private conditionalExpPart_ ::= ( condition_ conditionalOp_ condition_)
                                  | EXCL condition_ //must come after condition_ operator condition_ because ! would be preferred over != if it wasn't
                                  | NOT condition_
                                  | ASSERT LPAREN conditionalExpPart_ RPAREN
                                  | LPAREN conditionalExpPart_ RPAREN
                                  | conditionStandalone_


    private conditionalExp_ ::= conditionalExpPart_ ((AND | AMPAMP | OR | BARBAR) conditionalExp_)*

/*commandExp_*/
    private commandExp_ ::= LPAREN commandExp_ RPAREN //for where exp_ is not used and just commandExp_
                          | (valueExp_)? COMMAND codeBlock_ //must go first after LPAREN commandExp_ RPAREN. for some reason, if it is before (valueExp_)? COMMAND (exp_)?, [] spawn {...} breaks
                          | (valueExp_)? COMMAND (exp_)?

/*configExp_*/
    private configHolder_ ::= CONFIG | identifier_ | STRING_LITERAL | commandExp_
    private configExp_ ::= configHolder_ GTGT configHolder_ (GTGT configHolder_)*
                         | configHolder_ FSLASH configHolder_ (FSLASH configHolder_)*

/*mathExp_*/
    private mathOp_ ::= PLUS | MINUS | ASTERISK | CARET | PERC | MOD | FSLASH
    private mathExp_ ::= commandExpOrValue_ mathOp_ mathRhs_

    private mathRhs_ ::= LPAREN mathRhs_ RPAREN
					   | (commandExpOrValue_ mathOp_ mathRhs_)+
                       | commandExpOrValue_

/*valueExp_*/
    private valueExp_ ::= identifier_ | literal_ | arrayVal_ | CONFIG | TYPE_NULL | NIL | TRUE | FALSE | NAMESPACE
    private commandExpOrValue_ ::= commandExp_ | valueExp_ ; /*commandExp must go first since some commands match value_ for their pre-params ("arr select 1" -> arr is pre-param)*/

    private arrayVal_ ::= PLUS? LBRACKET RBRACKET
                        | PLUS? LBRACKET (exp_ | codeBlock_) (COMMA (exp_ | codeBlock_))* RBRACKET


/*control structures and other things*/
    private private_declaration_ ::= PRIVATE (STRING_LITERAL | LBRACKET (STRING_LITERAL (COMMA STRING_LITERAL)*) RBRACKET)

    private scopeManager_ ::= GOTO COLON STRING_LITERAL
                            | BREAK_TO STRING_LITERAL
                            | exp_? BREAK_OUT STRING_LITERAL
                            | CONTINUE
                            | BREAK
                            | SCOPE_NAME STRING_LITERAL

    private controlStructure_ ::= ifStatement_ | switchStatement_ | loop_ | waitUntil_ | withStatement_ | quest_
    private ifStatement_ ::= IF LPAREN conditionalExp_ RPAREN (
                              THEN codeBlock_ (ELSE codeBlock_)?
                              | EXIT_WITH codeBlock_
                              | THROW valueExp_
                           )

    private switchStatement_ ::= SWITCH (LPAREN commandExpOrValue_ RPAREN | commandExpOrValue_) DO LBRACE (switchCase_)* RBRACE
    private switchCase_ ::= (CASE valueExp_ COLON codeBlock_ SEMICOLON)
                          | (DEFAULT codeBlock_ SEMICOLON)

    private loop_ ::= whileLoop_ | forLoop_
    private whileLoop_   ::= WHILE LBRACE conditionalExp_ RBRACE DO codeBlock_
    private forLoop_     ::= forLoopReg_ | forLoopFrom_ | forEachLoop_
    private forLoopReg_  ::= FOR LBRACKET codeBlock_ COMMA LBRACE exp_ RBRACE COMMA codeBlock_ RBRACKET DO codeBlock_
    private forLoopFrom_ ::= FOR STRING_LITERAL FROM exp_ TO exp_ (STEP exp_)? DO codeBlock_
    private forEachLoop_ ::= codeBlock_ FOR_EACH exp_

    private quest_ ::= QUEST conditionalExp_ COLON exp_

    private tryCatch_ ::= TRY codeBlock_ CATCH codeBlock_ /*_exception is predefined in catch block*/

    private waitUntil_ ::= WAIT_UNTIL codeBlock_

    private withStatement_ ::= WITH NAMESPACE DO codeBlock_
