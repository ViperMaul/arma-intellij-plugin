{
  parserClass="com.kaylerrenslow.plugin.lang.sqf.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.plugin.lang.sqf.psi"
  //psiImplPackage="com.kaylerrenslow.plugin.lang.sqf.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFTokenType"
}
// @formatter:off
sqfFile ::= item_* (returnStatement_)?

private item_ ::= whitespace_comment_ | statement_ | BAD_CHARACTER

private whitespace_comment_ ::= WHITE_SPACE | comment_

private identifier_ ::= LOCAL_VAR | IDENTIFIER | LANG_CONSTANT | LPAREN identifier_ RPAREN

private comment_ ::= COMMENT | COMMENT_KEYWORD STRING_LITERAL

private literal_ ::= STRING_LITERAL | (MINUS)? INTEGER_LITERAL | (MINUS)? DEC_LITERAL

//TODO allow copy of arrays: _test=+[0,1]
//TODO support #define
//TODO fix Strings that allow "" inside them. example="""hello""";
//TODO when making the header parser, use that parser for the .sqm and .ext. But .sqm and .ext will have their own lexer so that keywords can be highlighted.

private statement_ ::= (
                        assignment_
                        | commandExp_
                        | private_declaration_
                        | controlStructure_
                        | scopeManager_
                        | tryCatch_
                     ) SEMICOLON

private returnStatement_ ::= (commandExpOrValue_ | conditionalExp_) SEMICOLON? (whitespace_comment_ | BAD_CHARACTER)*
private codeBlock_ ::= LBRACE RBRACE | LBRACE (item_)* (returnStatement_)? RBRACE


private exp_ ::= LPAREN exp_ RPAREN
               | mathExp_
               | commandExp_ //command must come before value because commands sometimes require values prior to the command itself. For example:: [] spawn {}
               | value_
               | conditionalExp_

private assignment_ ::= identifier_ EQ ( (exp_ | codeBlock_ | assignment_) | (switchStatement_ | ifStatement_ ) )

private condition_ ::= TRUE | FALSE | commandExpOrValue_
private conditionStandalone_ ::= TRUE | FALSE | commandExp_ | identifier_
private conditionalExpPart_ ::= EXCL condition_
                              | NOT condition_
                              | ( condition_ (
                                               AMPAMP
                                              | AND
                                              | BARBAR
                                              | OR
                                              | EQEQ
                                              | NE
                                              | LT
                                              | GT
                                              | LE
                                              | GE
                                             ) condition_
                                )
                              | ASSERT LPAREN conditionalExpPart_ RPAREN
                              | LPAREN conditionalExpPart_ RPAREN
                              | conditionStandalone_


private conditionalExp_ ::= conditionalExpPart_ (AND | AMPAMP) conditionalExpPart_
                          | conditionalExpPart_ (OR | BARBAR) conditionalExpPart_
                          | conditionalExpPart_


private commandExp_ ::= (value_)? COMMAND codeBlock_
                      | (value_)? COMMAND LPAREN exp_ RPAREN
                      | (value_)? COMMAND (exp_)?
                      | LPAREN commandExp_ RPAREN

private mathOp_ ::= PLUS | MINUS | ASTERISK | CARET | PERC | MOD | FSLASH
private mathExp_ ::= LPAREN mathExp_ RPAREN
                   | commandExpOrValue_ mathOp_ mathRhs_

private mathRhs_ ::= commandExpOrValue_ mathOp_ mathRhs_ | commandExpOrValue_

/*VALUES*/
    private value_ ::= identifier_ | literal_ | arrayVal_ | configVal_ | TYPE_NULL | NIL | TRUE | FALSE | NAMESPACE
    private commandExpOrValue_ ::= commandExp_ | value_ ; /*commandExp must go first since some commands match value_ for their pre-params ("arr select 1" -> arr is pre-param)*/

    private arrayVal_  ::= LBRACKET RBRACKET | LBRACKET (exp_ | codeBlock_) (COMMA (exp_ | codeBlock_))* RBRACKET

    private configVal_ ::= CONFIG
                         | CONFIG FSLASH (STRING_LITERAL | identifier_) (FSLASH (STRING_LITERAL | identifier_))*
                         | CONFIG GTGT (STRING_LITERAL | identifier_) (GTGT (STRING_LITERAL | identifier_))*


/*CONTROL STRUCTURES AND OTHER THINGS*/
    private private_declaration_ ::= PRIVATE (STRING_LITERAL | LBRACKET (STRING_LITERAL (COMMA STRING_LITERAL)*) RBRACKET)

    private scopeManager_ ::= GOTO COLON STRING_LITERAL
                            | BREAK_TO STRING_LITERAL
                            | commandExpOrValue_? BREAK_OUT STRING_LITERAL
                            | CONTINUE
                            | BREAK
                            | SCOPE_NAME STRING_LITERAL

    private controlStructure_ ::= ifStatement_ | switchStatement_ | loop_ | waitUntil_ | withStatement_ | quest_
    private ifStatement_ ::= IF LPAREN conditionalExp_ RPAREN (
                              THEN codeBlock_ (ELSE codeBlock_)?
                              | EXIT_WITH codeBlock_
                              | THROW value_
                           )

    private switchStatement_ ::= SWITCH (LPAREN commandExpOrValue_ RPAREN | commandExpOrValue_) DO LBRACE (switchCase_)* RBRACE
    private switchCase_ ::= (CASE value_ COLON codeBlock_ SEMICOLON)
                          | (DEFAULT codeBlock_ SEMICOLON)

    private loop_ ::= whileLoop_ | forLoop_
    private whileLoop_   ::= WHILE LBRACE conditionalExp_ RBRACE DO codeBlock_
    private forLoop_     ::= forLoopReg_ | forLoopFrom_ | forEachLoop_
    private forLoopReg_  ::= FOR LBRACKET codeBlock_ COMMA LBRACE exp_ RBRACE COMMA codeBlock_ RBRACKET DO codeBlock_
    private forLoopFrom_ ::= FOR STRING_LITERAL FROM exp_ TO exp_ (STEP exp_)? DO codeBlock_
    private forEachLoop_ ::= codeBlock_ FOR_EACH exp_

    private quest_ ::= QUEST conditionalExp_ COLON commandExpOrValue_

    private tryCatch_ ::= TRY codeBlock_ CATCH codeBlock_ /*_exception is predefined in catch block*/

    private waitUntil_ ::= WAIT_UNTIL codeBlock_

    private withStatement_ ::= WITH NAMESPACE DO codeBlock_
