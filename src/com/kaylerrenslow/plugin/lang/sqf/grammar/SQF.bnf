{
  parserClass="com.kaylerrenslow.plugin.lang.sqf.parser.SQFParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="SQF"
  psiImplClassSuffix="Impl"
  psiPackage="com.kaylerrenslow.plugin.lang.sqf.psi"
  psiImplPackage="com.kaylerrenslow.plugin.lang.sqf.psi.impl"

  elementTypeHolderClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFTypes"
  elementTypeClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFElementType"
  tokenTypeClass="com.kaylerrenslow.plugin.lang.sqf.psi.SQFTokenType"
}
// @formatter:off
sqfFile ::= item_* (returnStatement_)?

private item_ ::= whitespace_comment_ | statement | BAD_CHARACTER

private whitespace_comment_ ::= WHITE_SPACE | comment_

variable ::= LOCAL_VAR | IDENTIFIER | LANG_CONSTANT | LPAREN variable RPAREN

private comment_ ::= COMMENT | COMMENT_KEYWORD STRING_LITERAL

private literal_ ::= STRING_LITERAL | (MINUS | PLUS)? INTEGER_LITERAL | (MINUS | PLUS)? DEC_LITERAL

//TODO allow copy of arrays: _test=+[0,1]
//TODO support #define


statement ::= ( assignment
			| commandExp
			| privateDeclaration
			| controlStructure
			| scopeManager
			| tryCatch
		 ) SEMICOLON

assignment ::= variable EQ ( (exp | codeBlock | assignment) | (switchStatement | ifStatement ) )

private returnStatement_ ::= exp SEMICOLON? (whitespace_comment_ | BAD_CHARACTER)*

codeBlock ::= LBRACE RBRACE | LBRACE (item_)* (returnStatement_)? RBRACE


exp ::= configExp //must come first since CONFIG is of type value
	  | conditionalExp //comes before mathExp
	  | mathExp //math must come before value because math contains values before operator. Also, don't put commandExp before this
	  | commandExp //command must come before value because commands sometimes require values prior to the command itself. For example:: [] spawn {}
	  | valueExp
	  /*do NOT add LPAREN exp RPAREN*/


/*conditionalExp*/
	private conditionBools_ ::= commandExpCondition_ | variable | TRUE | FALSE

    private conditionComparable_ ::= mathExp //math must come before value because math contains values before operator
								   | commandExpCondition_
								   | valueExp
	/*
		can't use the regular commandExp because it will parse a conditionalExp and !isNull player && player == player will break.
		!isNull -> conditionalExp
		conditionalExp player && player - > conditionalExp conditionalExp (BREAKS HERE)

		The first rule is required since the normal commandExp has exp and exp can allow parens
		See -> exp ::= LPAREN exp RPAREN
	*/
	private commandExpCondition_ ::= LPAREN commandExpCondition_ RPAREN
								   | (valueExp)? COMMAND LPAREN (configExp | mathExp | commandExpCondition_ | valueExp)? RPAREN
								   | (valueExp)? COMMAND (configExp | mathExp | commandExpCondition_ | valueExp)?


	/*commandExpCondition_ should not be alone in conditionalPart_ because a conditionalExp would override commandExp in a majority of cases.
		In cases where conditionalExps are required (if statement for example), use conditionalExpReq

		variables also can't be in here for similar reasons.
	*/
    private conditionCheck_ ::= ( conditionComparable_ (EQEQ | NE | LT | GT | LE | GE) conditionComparable_)
							  | (conditionBools_ (AMPAMP | AND | BARBAR | OR) conditionBools_)
							  | EXCL (conditionBools_ | conditionalExpGroup_) //must come after condition operator condition because ! would be preferred over != if it wasn't
							  | NOT (conditionBools_ | conditionalExpGroup_)
							  | ASSERT LPAREN conditionalExp RPAREN
							  | LPAREN conditionCheck_ RPAREN
							  | TRUE
							  | FALSE

    private conditionStandalone_ ::= commandExpCondition_ | variable

	private conditionalExpGroup_ ::= LPAREN conditionalExp RPAREN
    conditionalExp ::= conditionalExpGroup_
    				 | conditionCheck_ ((AND | AMPAMP | OR | BARBAR) (conditionalExp | conditionStandalone_))*

    conditionalExpReq ::= LPAREN conditionalExpReq RPAREN
						| (conditionalExp | conditionStandalone_)

/*commandExp*/
    commandExp ::= LPAREN commandExp RPAREN //for where exp is not used and just commandExp
				 | (valueExp)? COMMAND codeBlock //must go first after LPAREN commandExp RPAREN. if it is not before (valueExp)? COMMAND (exp)?, [] spawn {...} breaks since exp isn't required
				 | (valueExp)? COMMAND (exp)? //even though commands can be invoked with math expressions and configs as an argument, we do not use (exp)? COMMAND (exp)? because math expressions can add commands
				 							  //1+1 command -> 1+commandExp -> 1 + 1 command

/*configExp*/
    private configHolder_ ::= CONFIG | variable | STRING_LITERAL | commandExp
    configExp ::= LPAREN configExp RPAREN
    			| configHolder_ GTGT configHolder_ (GTGT configHolder_)*
				| configHolder_ FSLASH configHolder_ (FSLASH configHolder_)*

/*mathExp*/
	mathExp ::= term_ ((PLUS | MINUS) term_)*

	private term_ ::= factor_ ((ASTERISK | FSLASH | MOD | PERC | CARET) factor_)*

	private factor_ ::= PLUS factor_
					  | MINUS factor_
					  | primary_

	private primary_ ::= commandExp
					   | literal_
					   | arrayVal
					   | variable
					   | LPAREN mathExp RPAREN


/*valueExp*/
    valueExp ::= LPAREN valueExp RPAREN /*this case is required*/ | variable | literal_ | arrayVal | CONFIG | TYPE_NULL | NIL | TRUE | FALSE | NAMESPACE
    private commandExpOrValueExp_ ::= commandExp | valueExp ; /*commandExp must go first since some commands match value for their pre-params ("arr select 1" -> arr is pre-param)*/

    arrayVal ::= LBRACKET RBRACKET
			   | LBRACKET (exp | codeBlock) (COMMA (exp | codeBlock))* RBRACKET

/*control structures and other things*/
    privateDeclaration ::= PRIVATE (STRING_LITERAL | LBRACKET (STRING_LITERAL (COMMA STRING_LITERAL)*) RBRACKET)

    scopeManager ::= GOTO COLON STRING_LITERAL
				   | BREAK_TO STRING_LITERAL
				   | exp? BREAK_OUT STRING_LITERAL
				   | CONTINUE
				   | BREAK
				   | SCOPE_NAME STRING_LITERAL

    controlStructure ::= ifStatement | switchStatement | loop_ | waitUntilStatement | withStatement | questStatement
    ifStatement ::= IF LPAREN conditionalExpReq RPAREN (
				    THEN codeBlock (ELSE codeBlock)?
				  | EXIT_WITH codeBlock
				  | THROW valueExp
			   )

    switchStatement ::= SWITCH (LPAREN commandExpOrValueExp_ RPAREN | commandExpOrValueExp_) DO LBRACE (switchCase)* RBRACE
    switchCase ::= (CASE valueExp COLON codeBlock SEMICOLON)
				 | (DEFAULT codeBlock SEMICOLON)

    private loop_ ::= whileLoop | forLoops_
    whileLoop   ::= WHILE LBRACE conditionalExpReq RBRACE DO codeBlock
    private forLoops_     ::= forLoop | forLoopFrom | forEachLoop
    forLoop  ::= FOR LBRACKET codeBlock COMMA LBRACE exp RBRACE COMMA codeBlock RBRACKET DO codeBlock
    forLoopFrom ::= FOR STRING_LITERAL FROM exp TO exp (STEP exp)? DO codeBlock
    forEachLoop ::= codeBlock FOR_EACH exp

    questStatement ::= QUEST conditionalExpReq COLON exp

    tryCatch ::= TRY codeBlock CATCH codeBlock

    waitUntilStatement ::= WAIT_UNTIL codeBlock

    withStatement ::= WITH NAMESPACE DO codeBlock
